// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: schedule.sql

package db

import (
	"context"
	"database/sql"
)

const checkScheduleConflicts = `-- name: CheckScheduleConflicts :one
SELECT EXISTS (
  SELECT 1 FROM schedules
  WHERE time_slot = $1 AND (
    room_id = $2 OR 
    teacher_email = $3 OR 
    group_id = $4
  )
) AS conflict_exists
`

type CheckScheduleConflictsParams struct {
	TimeSlot     sql.NullString `json:"time_slot"`
	RoomID       sql.NullInt64  `json:"room_id"`
	TeacherEmail sql.NullString `json:"teacher_email"`
	GroupID      sql.NullInt64  `json:"group_id"`
}

func (q *Queries) CheckScheduleConflicts(ctx context.Context, arg CheckScheduleConflictsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkScheduleConflicts,
		arg.TimeSlot,
		arg.RoomID,
		arg.TeacherEmail,
		arg.GroupID,
	)
	var conflict_exists bool
	err := row.Scan(&conflict_exists)
	return conflict_exists, err
}

const countSchedules = `-- name: CountSchedules :one
SELECT count(*) FROM schedules
`

func (q *Queries) CountSchedules(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSchedules)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (
  group_id,
  room_id,
  subject_id,
  teacher_email,
  time_slot
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, group_id, room_id, subject_id, teacher_email, time_slot
`

type CreateScheduleParams struct {
	GroupID      sql.NullInt64  `json:"group_id"`
	RoomID       sql.NullInt64  `json:"room_id"`
	SubjectID    sql.NullInt64  `json:"subject_id"`
	TeacherEmail sql.NullString `json:"teacher_email"`
	TimeSlot     sql.NullString `json:"time_slot"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, createSchedule,
		arg.GroupID,
		arg.RoomID,
		arg.SubjectID,
		arg.TeacherEmail,
		arg.TimeSlot,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RoomID,
		&i.SubjectID,
		&i.TeacherEmail,
		&i.TimeSlot,
	)
	return i, err
}

const deleteSchedule = `-- name: DeleteSchedule :exec
DELETE FROM schedules
WHERE id = $1
`

func (q *Queries) DeleteSchedule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSchedule, id)
	return err
}

const getSchedule = `-- name: GetSchedule :one
SELECT id, group_id, room_id, subject_id, teacher_email, time_slot FROM schedules
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSchedule(ctx context.Context, id int64) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, getSchedule, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RoomID,
		&i.SubjectID,
		&i.TeacherEmail,
		&i.TimeSlot,
	)
	return i, err
}

const getSchedulesByGroup = `-- name: GetSchedulesByGroup :many
SELECT s.id, s.group_id, s.room_id, s.subject_id, s.teacher_email, s.time_slot, 
  t.name AS teacher_name,
  r.room_code,
  r.block_no,
  sub.subject_code,
  sub.name AS subject_name,
  ss.name AS group_name
FROM schedules s
JOIN teacher t ON s.teacher_email = t.email
JOIN room r ON s.room_id = r.id
JOIN subject sub ON s.subject_id = sub.id
JOIN student_section ss ON s.group_id = ss.id
WHERE s.group_id = $1
ORDER BY s.time_slot
`

type GetSchedulesByGroupRow struct {
	ID           int64          `json:"id"`
	GroupID      sql.NullInt64  `json:"group_id"`
	RoomID       sql.NullInt64  `json:"room_id"`
	SubjectID    sql.NullInt64  `json:"subject_id"`
	TeacherEmail sql.NullString `json:"teacher_email"`
	TimeSlot     sql.NullString `json:"time_slot"`
	TeacherName  sql.NullString `json:"teacher_name"`
	RoomCode     sql.NullString `json:"room_code"`
	BlockNo      sql.NullString `json:"block_no"`
	SubjectCode  sql.NullString `json:"subject_code"`
	SubjectName  sql.NullString `json:"subject_name"`
	GroupName    sql.NullString `json:"group_name"`
}

func (q *Queries) GetSchedulesByGroup(ctx context.Context, groupID sql.NullInt64) ([]GetSchedulesByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulesByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchedulesByGroupRow
	for rows.Next() {
		var i GetSchedulesByGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RoomID,
			&i.SubjectID,
			&i.TeacherEmail,
			&i.TimeSlot,
			&i.TeacherName,
			&i.RoomCode,
			&i.BlockNo,
			&i.SubjectCode,
			&i.SubjectName,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesByRoom = `-- name: GetSchedulesByRoom :many
SELECT s.id, s.group_id, s.room_id, s.subject_id, s.teacher_email, s.time_slot, 
  t.name AS teacher_name,
  r.room_code,
  r.block_no,
  sub.subject_code,
  sub.name AS subject_name,
  ss.name AS group_name
FROM schedules s
JOIN teacher t ON s.teacher_email = t.email
JOIN room r ON s.room_id = r.id
JOIN subject sub ON s.subject_id = sub.id
JOIN student_section ss ON s.group_id = ss.id
WHERE s.room_id = $1
ORDER BY s.time_slot
`

type GetSchedulesByRoomRow struct {
	ID           int64          `json:"id"`
	GroupID      sql.NullInt64  `json:"group_id"`
	RoomID       sql.NullInt64  `json:"room_id"`
	SubjectID    sql.NullInt64  `json:"subject_id"`
	TeacherEmail sql.NullString `json:"teacher_email"`
	TimeSlot     sql.NullString `json:"time_slot"`
	TeacherName  sql.NullString `json:"teacher_name"`
	RoomCode     sql.NullString `json:"room_code"`
	BlockNo      sql.NullString `json:"block_no"`
	SubjectCode  sql.NullString `json:"subject_code"`
	SubjectName  sql.NullString `json:"subject_name"`
	GroupName    sql.NullString `json:"group_name"`
}

func (q *Queries) GetSchedulesByRoom(ctx context.Context, roomID sql.NullInt64) ([]GetSchedulesByRoomRow, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulesByRoom, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchedulesByRoomRow
	for rows.Next() {
		var i GetSchedulesByRoomRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RoomID,
			&i.SubjectID,
			&i.TeacherEmail,
			&i.TimeSlot,
			&i.TeacherName,
			&i.RoomCode,
			&i.BlockNo,
			&i.SubjectCode,
			&i.SubjectName,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesByTeacher = `-- name: GetSchedulesByTeacher :many
SELECT s.id, s.group_id, s.room_id, s.subject_id, s.teacher_email, s.time_slot, 
  t.name AS teacher_name,
  r.room_code,
  r.block_no,
  sub.subject_code,
  sub.name AS subject_name,
  ss.name AS group_name
FROM schedules s
JOIN teacher t ON s.teacher_email = t.email
JOIN room r ON s.room_id = r.id
JOIN subject sub ON s.subject_id = sub.id
JOIN student_section ss ON s.group_id = ss.id
WHERE s.teacher_email = $1
ORDER BY s.time_slot
`

type GetSchedulesByTeacherRow struct {
	ID           int64          `json:"id"`
	GroupID      sql.NullInt64  `json:"group_id"`
	RoomID       sql.NullInt64  `json:"room_id"`
	SubjectID    sql.NullInt64  `json:"subject_id"`
	TeacherEmail sql.NullString `json:"teacher_email"`
	TimeSlot     sql.NullString `json:"time_slot"`
	TeacherName  sql.NullString `json:"teacher_name"`
	RoomCode     sql.NullString `json:"room_code"`
	BlockNo      sql.NullString `json:"block_no"`
	SubjectCode  sql.NullString `json:"subject_code"`
	SubjectName  sql.NullString `json:"subject_name"`
	GroupName    sql.NullString `json:"group_name"`
}

func (q *Queries) GetSchedulesByTeacher(ctx context.Context, teacherEmail sql.NullString) ([]GetSchedulesByTeacherRow, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulesByTeacher, teacherEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchedulesByTeacherRow
	for rows.Next() {
		var i GetSchedulesByTeacherRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RoomID,
			&i.SubjectID,
			&i.TeacherEmail,
			&i.TimeSlot,
			&i.TeacherName,
			&i.RoomCode,
			&i.BlockNo,
			&i.SubjectCode,
			&i.SubjectName,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchedules = `-- name: ListSchedules :many
SELECT id, group_id, room_id, subject_id, teacher_email, time_slot FROM schedules
ORDER BY time_slot
LIMIT $1
OFFSET $2
`

type ListSchedulesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSchedules(ctx context.Context, arg ListSchedulesParams) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, listSchedules, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RoomID,
			&i.SubjectID,
			&i.TeacherEmail,
			&i.TimeSlot,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE schedules
SET 
  group_id = $2,
  room_id = $3,
  subject_id = $4,
  teacher_email = $5,
  time_slot = $6
WHERE id = $1
RETURNING id, group_id, room_id, subject_id, teacher_email, time_slot
`

type UpdateScheduleParams struct {
	ID           int64          `json:"id"`
	GroupID      sql.NullInt64  `json:"group_id"`
	RoomID       sql.NullInt64  `json:"room_id"`
	SubjectID    sql.NullInt64  `json:"subject_id"`
	TeacherEmail sql.NullString `json:"teacher_email"`
	TimeSlot     sql.NullString `json:"time_slot"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, updateSchedule,
		arg.ID,
		arg.GroupID,
		arg.RoomID,
		arg.SubjectID,
		arg.TeacherEmail,
		arg.TimeSlot,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RoomID,
		&i.SubjectID,
		&i.TeacherEmail,
		&i.TimeSlot,
	)
	return i, err
}
